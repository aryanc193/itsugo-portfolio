---
title: "Keeper DApp — Decentralized Note App"
year: 2025
id: 9
repo: "https://github.com/aryanc193/keeper-dapp"
demo: ""
tags:
  - Motoko
  - React
  - Internet Computer
seo: "A decentralized, Google-Keep-style note app built with Motoko and React."
---

![Homepage screenshot](/projects/keeper.png)

# Keeper DApp — Case Study

> A Google Keep–style decentralized note app built using a Motoko backend canister and a React frontend.  
> Lightweight, private, and fully on-chain.

---

## Background / Why This Matters

Most note-taking apps rely on centralized databases.  
I wanted to explore what happens when:

- **the backend is a Motoko canister**
- **the storage is stable memory**
- **authentication is Internet Identity**
- **there is no server, no database, no vendor**

The goal was to see how far a small, fast, fully decentralized UX could go.

---

## Project Goal

Build a simple, private, low-latency note app where:

- notes sync instantly (optimistic UI)
- storage persists across canister upgrades
- cycle usage stays efficient
- dev experience works smoothly in both local and production networks

---

## My Role

I built the entire project:

- Motoko backend canister
- React/Vite frontend
- Stable-memory storage schema
- Internet Identity login
- Optimistic UI syncing flow

---

## Architecture Overview

### **Frontend**

- React + Vite
- Optimistic UI for instant note creation
- Local shadow-state buffer to reduce backend calls

### **Backend (Motoko)**

- Notes stored in stable variables
- Array-like table design (`{ id; text; timestamp }`)
- Upgrade-safe storage
- Batching logic to reduce cycles

### **Authentication**

- Internet Identity
- Local dev root-key fetching patch
- Shared agent config for local/production

---

## How It Works (Flow)

1. User creates or edits a note.
2. Optimistic UI updates instantly (no waiting).
3. Notes are added to a **write buffer**.
4. Buffer flushes periodically → Motoko canister writes.
5. Notes stored in stable memory, remain across upgrades.

This flow makes the app feel like a central server exists — even though it doesn’t.

---

## Key Challenges & Solutions

### **1. Cycle Cost & Write Efficiency**

**Problem:**  
Frequent writes to the canister were expensive and unnecessary.

**Solution:**

- Added a batching layer
- Compressed write payloads
- Reduced API calls by ~80% during fast typing

**Why it mattered:**  
Made the app practical and cheap to run.

---

### **2. “Certificate Not Found” in Local Development**

**Problem:**  
Local agents on the IC require fetching a root key.  
Without it, calls fail and debugging becomes painful.

**Solution:**  
Conditional initialization:

```
if (process.env.DFX_NETWORK === "local") {
  const agent = new HttpAgent({ host: "http://localhost:4943" });
  await agent.fetchRootKey();
  dkeeper_backend = createActor(canisterId, { agent });
} else {
  dkeeper_backend = createActor(canisterId, { agent: new HttpAgent() });
}
Impact:
Local DX became smooth and predictable.
```

---

### **3. Stable-Structure Design**

- Tradeoff:
  - Dynamic collections are flexible but error-prone during upgrades.
- Decision:
  - Use a fixed-shape stable list:
- predictable
- upgrade-safe
- ideal for small workloads

---

## **Outcomes / Learnings**

Even though this project is private, it taught me:

- stable-memory patterns are fundamental on the IC
- optimistic UI dramatically improves UX
- batching writes can reduce cycle burn significantly
- backend agent configuration affects everything
- Motoko upgrades require careful data planning

This project became a strong foundation for future decentralized work.

---

# **Final Thoughts**

Keeper DApp helped me understand what “small, decentralized apps” really feel like to build.
It’s simple, but it taught me more about on-chain persistence and cycle-aware design than much larger projects.
